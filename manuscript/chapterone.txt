# **Laravel on AWS: a reference architecture**

## **A guide to networking, security, autoscaling and high-availability**


It's not an easy task to setup a durable architecture for your web application. And if you try to build it as you go, you'll soon get tired of clicking around the AWS console. What if you had one go-to architecture and repeatable process for all your projects, while ensuring maximum security, performance and availability? Here is how you should deploy your Laravel application on AWS.


## **How we will enforce security:**


-Create *VPC subnets* to deploy our application into. A VPC is your own virtual network within AWS and lets you design private subnets where instances can't be accessed directly from outside your VPC. This is where we will deploy our web and database instances.


-Use temporary *bastions* (also called jump boxes) that we will deploy in our public subnets when we need to connect to web and database instances, reducing the surface of attack


-Enforce firewalls rules by whitelisting which servers can talk to each other, using *VPC security groups (SGs)*. SGs are default-deny stateful firewalls applied at the instance level.


-Simplify secret management by avoiding passwords when possible and instead specifying *IAM roles* to control access to our resources. Using IAM roles for EC2 removes the need to store AWS credentials in a configuration file. Roles use temporary security tokens under the hood which AWS takes care of rotating so we don't have to worry about updating passwords.


## **How we will enforce high availability:**


-Span our application instances across Availability Zones (AZs below). An AZ is one or more data centers within a region that are designed to be isolated from failures in other AZs. By placing resources in separate AZs, orgnisations can protect their application from a service disruption impacting a single location


-Serve our application from an Elastic Load Balancer. ELB is a highly available (distributed) service that distributes traffic across a group of EC2 instances in one or more AZs. ELB supports *health checks* to ensure traffic is not routed to unhealthy or failing instances


-Host our application on ECS, describing through *ECS services* what minimum number of healthy application containers should be running at any given time. ECS services will start new containers if one ever crashes.


-Distribute our database as a cluster across multiple AZs. RDS allows you to place a secondary copy of your database in another AZ for disaster recovery purpose. You are assigned a database endpoint in the form of a DNS name that AWS takes responsibility for resolving to a specific IP address. RDS will automatically fail over to the standby instance without user intervention. Preferably we will be using Amazon Aurora, which will maintain a read replica of our database in a separate AZ and that Amazon will promote as the primary instance should our main instance (or its AZ) fail.


-Finally, we rely on as many *distributed services* as possible to delegate failure management to AWS: services like S3, SQS, ELB/ALB, ECR and CloudWatch are designed for maximum resiliency without us having to care for the instances they run on.


![Laravel, made highly available with almost a one-click deploy!](images/fig01.png)


## **How we will build ourselves a repeatable process:**


We will be deploying an empty Laravel application on a fresh domain name using Docker, CloudFormation and the AWS CLI. CloudFormation defines a templating language that can be used to describe all the AWS resources that are necessary for a workload. Templates are submitted to CloudFormation and the service will provision and configure those resources in appropriate order.


Docker container images are stand-alone, executable packages of a piece of software that include everything needed to run it.


With the AWS CLI, you can control all services from the command line and automate them through scripts.


By combining all three, both our infrastructure and our application configuration can be written as code and as such be versioned, branched, documented.


*This is the procedure I use to deploy my clients' Laravel applications on AWS. I hope this can be helpful to deploy yours. If your use case is more complex, I provide on-going support packages ranging from mentoring your developers up to hands-on building your application on AWS. Ping me at [hi@getlionel.com](mailto:hi@getlionel.com)*


## **Let's do it step by step:**


## **1. Setup your AWS credentials**


Start with authenticating your command line by downloading the API key and secret for a new user in the IAM section of your AWS console. This user will need to have to have permissions to create resources for all the services we will use below. Follow the prompts from:


```no-highlight
       aws configure
```

C> `Use the profile option to save different credentials for different projects`


## **2. Order SSL certificates**


We need two certificates: one for our web application itself and another one for our custom domain on CloudFront. The one for your web application needs to be created in the AWS region you want to deploy your application into whereas CloudFront will only accept certificates generated in region *us-east-1*.


AWS SSL/TLS certificates are free, automatically provisioned and renewed, even if you did not buy your domain in Route53. They seamlessly integrate with AWS load balancers, CloudFront distributions and API Gateway endpoints so you can just set them and forget them.


```no-highlight
       # a certificate in your default region for your web application
       aws acm request-certificate
                       --domain-name [laravelaws.com](http://laravelaws.com)
                       --idempotency-token=random_string_here
                       --subject-alternative-names *.[laravelaws.com](http://laravelaws.com)

        # a certificate from us-east-1 specifically for our CloudFront custom domain
        aws --region us-east-1 acm request-certificate
                       --domain-name [laravelaws.com](http://laravelaws.com)
                       --idempotency-token=random_string_here
                       --subject-alternative-names *.[laravelaws.com](http://laravelaws.com)
```

## **3. Create a key pair to be used by your EC2 instances**


It is recommended to create a new SSH key pair for all EC2 instances of this new project, still using the CLI:


```no-highlight
       # Create the key pair and extract the private key from the JSON response
       aws ec2 create-key-pair
                      --key-name=laravelaws
                      --query 'KeyMaterial'
                      --output text &#62; laravelaws.pem

       # Assign appropriate permissions to the key file for it to be usable
       chmod 400 laravelaws.pem
```

Remember that AWS won't store SSH keys for you and you are responsible for storing and sharing them securely.


## **4. Launch our CloudFormation stacks**


Here comes the infrastructure-as-code! Our whole deployment will be described in one master YAML template, itself referencing *nested stacks* YAML templates to make it more readable and reusable.


This is the directory structure of our templates:

```no-highlight
      |-- master.yaml
      |-- infrastructure
                 |-- vpc.yaml
                 |-- storage.yaml
                 |-- web.yaml
                 |-- services.yaml
      # *the root template*
      # *our VPC and security groups*
      # *our database cluster and S3 bucket*
      # *our ECS cluster*
      # *our ECS Tasks Definitions &#38; Services*
```

And the complete code can be downloaded from GitHub here:

A>## **li0nel/laravelaws**
A>
A> laravelaws - A reference architecture to deploy Laravel on AWS
A>
A> github.com
!(images/fig01.png)

## The *vpc.yaml* template defines our *VPC subnets* and *route tables*:

<pre lang="no-highlight"><code>```javascript
var s = "JavaScript syntax highlighting";
alert(s);
```

```python
s = "Python syntax highlighting"
print s
```

```
   VPC
   # This template creates a VPC and a pair public and private subnets spanning the first two AZs of your current region.
   # Each instance in the public subnet can accessed the internet and be accessed from the internet
   # thanks to a route table routing traffic through the Internet Gateway.
   # Private subnets feature a NAT Gateway located in the public subnet of the same AZ, so they can receive traffic
   # from within the VPC.
   VPC:
      Type: AWS::EC2::VPC
      Properties:
         CidrBlock: !Ref VpcCIDR
         Tags:
             - Key: Name
               Value: !Ref EnvironmentName


   InternetGateway:
      Type: AWS::EC2::InternetGateway
      Properties:
         Tags:
             - Key: Name
               Value: !Ref EnvironmentName


   InternetGatewayAttachment:
      Type: AWS::EC2::VPCGatewayAttachment
      Properties:
         InternetGatewayId: !Ref InternetGateway
         VpcId: !Ref VPC


   PublicSubnet1:
      Type: AWS::EC2::Subnet
      Properties:
         VpcId: !Ref VPC
         AvailabilityZone: !Select [ 0, !GetAZs ]
         CidrBlock: !Ref PublicSubnet1CIDR
         MapPublicIpOnLaunch: true
         Tags:
             - Key: Name
               Value: !Sub ${EnvironmentName} Public Subnet (AZ1)


   PublicSubnet2:
      Type: AWS::EC2::Subnet
      Properties:
         VpcId: !Ref VPC
         AvailabilityZone: !Select [ 1, !GetAZs ]
         CidrBlock: !Ref PublicSubnet2CIDR
         MapPublicIpOnLaunch: true
         Tags:
             - Key: Name
               Value: !Sub ${EnvironmentName} Public Subnet (AZ2)


   PrivateSubnet1:
      Type: AWS::EC2::Subnet
      Properties:
         VpcId: !Ref VPC
         AvailabilityZone: !Select [ 0, !GetAZs ]
         CidrBlock: !Ref PrivateSubnet1CIDR
         MapPublicIpOnLaunch: false
         Tags:
             - Key: Name
               Value: !Sub ${EnvironmentName} Private Subnet (AZ1)


   PrivateSubnet2:
      Type: AWS::EC2::Subnet
      Properties:
         VpcId: !Ref VPC
         AvailabilityZone: !Select [ 1, !GetAZs ]
         CidrBlock: !Ref PrivateSubnet2CIDR
         MapPublicIpOnLaunch: false
         Tags:
             - Key: Name
               Value: !Sub ${EnvironmentName} Private Subnet (AZ2)


   NatGateway1EIP:
      Type: AWS::EC2::EIP
      DependsOn: InternetGatewayAttachment
      Properties:
         Domain: vpc


   NatGateway2EIP:
      Type: AWS::EC2::EIP
      DependsOn: InternetGatewayAttachment
      Properties:
         Domain: vpc


   NatGateway1:
      Type: AWS::EC2::NatGateway
      Properties:
         AllocationId: !GetAtt NatGateway1EIP.AllocationId
         SubnetId: !Ref PublicSubnet1


   NatGateway2:
      Type: AWS::EC2::NatGateway
      Properties:
         AllocationId: !GetAtt NatGateway2EIP.AllocationId
         SubnetId: !Ref PublicSubnet2


   PublicRouteTable:
      Type: AWS::EC2::RouteTable
      Properties:
         VpcId: !Ref VPC
         Tags:
             - Key: Name
               Value: !Sub ${EnvironmentName} Public Routes


   DefaultPublicRoute:
      Type: AWS::EC2::Route
      DependsOn: InternetGatewayAttachment
      Properties:
         RouteTableId: !Ref PublicRouteTable
         DestinationCidrBlock: 0.0.0.0/0
         GatewayId: !Ref InternetGateway


   PublicSubnet1RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
         RouteTableId: !Ref PublicRouteTable
         SubnetId: !Ref PublicSubnet1


   PublicSubnet2RouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
         RouteTableId: !Ref PublicRouteTable
         SubnetId: !Ref PublicSubnet2



   PrivateRouteTable1:
      Type: AWS::EC2::RouteTable
      Properties:
         VpcId: !Ref VPC
         Tags:
             - Key: Name
               Value: !Sub ${EnvironmentName} Private Routes (AZ1)


   DefaultPrivateRoute1:
       Type: AWS::EC2::Route
       Properties:
       RouteTableId: !Ref PrivateRouteTable1
       DestinationCidrBlock: 0.0.0.0/0
       NatGatewayId: !Ref NatGateway1


   PrivateSubnet1RouteTableAssociation:
     Type: AWS::EC2::SubnetRouteTableAssociation
     Properties:
       RouteTableId: !Ref PrivateRouteTable1
       SubnetId: !Ref PrivateSubnet1


   PrivateRouteTable2:
     Type: AWS::EC2::RouteTable
     Properties:
       VpcId: !Ref VPC
       Tags:
         - Key: Name
         Value: !Sub ${EnvironmentName} Private Routes (AZ2)


   DefaultPrivateRoute2:
     Type: AWS::EC2::Route
     Properties:
       RouteTableId: !Ref PrivateRouteTable2
       DestinationCidrBlock: 0.0.0.0/0
       NatGatewayId: !Ref NatGateway2


   PrivateSubnet2RouteTableAssociation:
     Type: AWS::EC2::SubnetRouteTableAssociation
     Properties:
       RouteTableId: !Ref PrivateRouteTable2
       SubnetId: !Ref PrivateSubnet2
```
</code></pre>


## Images

```no-highlight
Here's our logo (hover to see the title text):

Inline-style:
![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png "Logo Title Text 1")

Reference-style:
![alt text][logo]

[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png "Logo Title Text 2"
```
